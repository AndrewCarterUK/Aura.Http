<?php
/**
 * 
 * This file is part of the Aura project for PHP.
 * 
 * @license http://opensource.org/licenses/bsd-license.php BSD
 * 
 */
namespace Aura\Http\Cookie;

use Aura\Http\Exception as Exception;
use Aura\Http\Cookie;
use Aura\Http\Cookie\Factory as CookieFactory;

/**
 * 
 * Create and read a Netscape HTTP cookie file
 * 
 * @see http://curl.haxx.se/rfc/cookie_spec.html
 * 
 * @package Aura.Http
 * 
 */
class Jar
{
    /**
     * 
     * @var array The list of cookies.
     * 
     */
    protected $list = [];

    /**
     * 
     * @var Aura\Http\Cookie\Factory
     * 
     */
    protected $factory;
    
    /**
     * 
     * @var boolean Has the cookiejar file been opened.
     * 
     */
    protected $opened = false;

    /**
     * 
     * @var boolean
     * 
     */
    protected $expire_session_cookies = false;

    public function __construct(CookieFactory $factory)
    {
        $this->factory = $factory;
    }
    
    /**
     *
     * Expire session cookies. Must be called before `open()` and `open()` will
     * set `expireSessionCookies()` to false.
     * 
     * @param boolean $expire
     *
     */
    public function expireSessionCookies($expire = true)
    {
        $this->expire_session_cookies = $expire;
    }

    /**
     *
     * Add a Aura\Http\Cookie to the cookiejar. The cookie will not be written 
     * until `save()` is called.
     * 
     * @param Aura\Http\Cookie $cookie
     *
     */
    public function add(Cookie $cookie)
    {
        $key = $cookie->getName() . $cookie->getDomain() . $cookie->getPath();
        $this->list[$key] = $cookie;
    }

    /**
     *
     * Open a cookiejar file.
     *
     * @param string $file
     *
     * @return boolean
     *
     */
    public function open($file)
    {
        if ($this->opened) {
            return false;
        }

        $cookies = file_get_contents($file);
        $cookies = explode("\n", $cookies);

        foreach($cookies as $line) {
            $this->parseLine($line);
        }

        $this->expireSessionCookies(false);
        $this->opened = true;

        return true;
    }


    /**
     *
     * Save the cookies to the $file.
     *
     * @param string $file 
     *
     * @return boolean
     *
     */
    public function save($file)
    {
        if (! $this->list) {
            return false;
        }

        $lines = [];

        foreach ($this->list as $cookie) {
            $lines[] = $this->buildLine($cookie);
        }

        $this->opened = false;
        $this->list   = [];

        $msg = "# Netscape HTTP Cookie File\n" .
               "# http://curl.haxx.se/rfc/cookie_spec.html\n" .
               "# This file was generated by Aura\Http\Request! " .
               "Edit at your own risk.\n\n";

        return false !== file_put_contents($file, $msg . implode("\n", $lines));
    }

    /**
     *
     * List all stored cookies with an optional matching URL. The matching URL
     * must contain a scheme and host.
     *
     * @param string $matching_url
     *
     * @return array
     * 
     * @throws Aura\Http\Exception If the matching URL does not contain a
     * scheme or domain.
     *
     */
    public function listAll($matching_url = null)
    {
        if (! $matching_url) {
            return $this->list;
        }

        $url = parse_url($matching_url);

        if (! isset($url['scheme'], $url['host'])) {
            $msg = 'The `$matching_url` argument must contain a ' .
                   'scheme and a host name.';
            throw new Exception($msg);
        }

        $path = empty($url['path']) ? '/' : $url['path'];
        $return = [];

        foreach ($this->list as $key => $cookie) {
            if ($cookie->isMatch($url['scheme'], $url['host'], $path)) {
                $return[$key] = $cookie;
            }
        }

        return $return;
    }

    /**
     *
     * Parse one line of the cookie file.
     *
     * @param string $line The cookie line
     *
     */
    protected function parseLine($line)
    {
        $line = trim($line);

        // Empty / commented line
        if ('' == $line || 
            ('#' == $line[0] && '#HttpOnly_' != substr($line, 0, 10))) {
            return;
        }

        $parts    = explode("\t", $line);

        // Malformed line
        if (7 != count($parts)) {
            return;
        }

        $httponly = false;
        $domain   = $parts[0];

        if (strlen($parts[0]) > 10) {
            $httponly = substr($parts[0], 0, 10);
            $httponly = (boolean) ('#HttpOnly_' == $httponly);

            if ($httponly) {
                $domain   = substr($parts[0], 10);
            }
        }

        $cookie = $this->factory->newInstance(
            $parts[5], // name
            [
            'value'    => $parts[6], 
            'expire'   => $parts[4], 
            'path'     => $parts[2], 
            'domain'   => $domain,   
            'secure'   => ('TRUE' == $parts[3]) ? true : false, 
            'httponly' => $httponly
            ]  
        );

        if (! $cookie->isExpired($this->expire_session_cookies)) {
            $key = $parts[5] . $domain . $parts[2];
            $this->list[$key] = $cookie;
        }
    }

    /**
     *
     * Build a line based on Aura\Http\Cookie for the cookiejar file.
     * 
     * @param Aura\Http\Cookie
     *
     * @return string
     *
     */
    protected function buildLine(Cookie $cookie)
    {
        $domain = $cookie->getDomain();
        $expire = $cookie->getExpire();
        $path   = $cookie->getPath();

        if ($cookie->getHttpOnly()) {
            $domain = '#HttpOnly_' . $domain;
        }

        return sprintf(
            "%s\t%s\t%s\t%s\t%s\t%s\t%s",
            $domain,
            ('.' == $cookie->getDomain()[0]) ? 'TRUE' : 'FALSE',
            $path ?: '/',
            $cookie->getSecure() ? 'TRUE' : 'FALSE',
            $expire ?: '0',
            $cookie->getName(),
            $cookie->getValue()
        );
    }
}